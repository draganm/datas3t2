// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package postgresstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBucket = `-- name: AddBucket :exec
INSERT INTO s3_buckets (
        name,
        endpoint,
        bucket,
        access_key,
        secret_key,
        use_tls
    )
VALUES ($1, $2, $3, $4, $5, $6)
`

type AddBucketParams struct {
	Name      string
	Endpoint  string
	Bucket    string
	AccessKey string
	SecretKey string
	UseTls    bool
}

func (q *Queries) AddBucket(ctx context.Context, arg AddBucketParams) error {
	_, err := q.db.Exec(ctx, addBucket,
		arg.Name,
		arg.Endpoint,
		arg.Bucket,
		arg.AccessKey,
		arg.SecretKey,
		arg.UseTls,
	)
	return err
}

const addDatarangeUpload = `-- name: AddDatarangeUpload :one
INSERT INTO datarange_uploads (datarange_id, first_datapoint_index, number_of_datapoints, data_size)
SELECT dr.id, $1, $2, $3
FROM dataranges dr
JOIN datasets d ON dr.dataset_id = d.id
WHERE d.name = $4
  AND dr.data_object_key = $5
RETURNING id
`

type AddDatarangeUploadParams struct {
	FirstDatapointIndex int64
	NumberOfDatapoints  int64
	DataSize            int64
	Datas3tName         string
	DataObjectKey       string
}

func (q *Queries) AddDatarangeUpload(ctx context.Context, arg AddDatarangeUploadParams) (int64, error) {
	row := q.db.QueryRow(ctx, addDatarangeUpload,
		arg.FirstDatapointIndex,
		arg.NumberOfDatapoints,
		arg.DataSize,
		arg.Datas3tName,
		arg.DataObjectKey,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addDatas3t = `-- name: AddDatas3t :exec
INSERT INTO datasets (name, s3_bucket_id) 
SELECT $1, id 
FROM s3_buckets 
WHERE s3_buckets.name = $2
`

type AddDatas3tParams struct {
	DatasetName string
	BucketName  string
}

func (q *Queries) AddDatas3t(ctx context.Context, arg AddDatas3tParams) error {
	_, err := q.db.Exec(ctx, addDatas3t, arg.DatasetName, arg.BucketName)
	return err
}

const allAccessConfigs = `-- name: AllAccessConfigs :many
SELECT DISTINCT name
FROM s3_buckets
`

func (q *Queries) AllAccessConfigs(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, allAccessConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allDatasets = `-- name: AllDatasets :many
SELECT name
FROM datasets
`

func (q *Queries) AllDatasets(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, allDatasets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bucketExists = `-- name: BucketExists :one
SELECT count(*) > 0
FROM s3_buckets
WHERE name = $1
`

func (q *Queries) BucketExists(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, bucketExists, name)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const checkDatarangeOverlap = `-- name: CheckDatarangeOverlap :one
SELECT count(*) > 0
FROM dataranges
WHERE dataset_id = $1
  AND min_datapoint_key < $2
  AND max_datapoint_key >= $3
`

type CheckDatarangeOverlapParams struct {
	DatasetID       int64
	MinDatapointKey int64
	MaxDatapointKey int64
}

func (q *Queries) CheckDatarangeOverlap(ctx context.Context, arg CheckDatarangeOverlapParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDatarangeOverlap, arg.DatasetID, arg.MinDatapointKey, arg.MaxDatapointKey)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const countDatarangeUploads = `-- name: CountDatarangeUploads :one
SELECT count(*)
FROM datarange_uploads
`

func (q *Queries) CountDatarangeUploads(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDatarangeUploads)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDataranges = `-- name: CountDataranges :one
SELECT count(*)
FROM dataranges
`

func (q *Queries) CountDataranges(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDataranges)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countKeysToDelete = `-- name: CountKeysToDelete :one
SELECT count(*)
FROM keys_to_delete
`

func (q *Queries) CountKeysToDelete(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countKeysToDelete)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDatarange = `-- name: CreateDatarange :one
INSERT INTO dataranges (dataset_id, data_object_key, index_object_key, min_datapoint_key, max_datapoint_key, size_bytes)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateDatarangeParams struct {
	DatasetID       int64
	DataObjectKey   string
	IndexObjectKey  string
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
}

func (q *Queries) CreateDatarange(ctx context.Context, arg CreateDatarangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, createDatarange,
		arg.DatasetID,
		arg.DataObjectKey,
		arg.IndexObjectKey,
		arg.MinDatapointKey,
		arg.MaxDatapointKey,
		arg.SizeBytes,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDatarangeUpload = `-- name: CreateDatarangeUpload :one
INSERT INTO datarange_uploads (
    datarange_id, 
    upload_id,
    data_object_key,
    index_object_key,
    first_datapoint_index, 
    number_of_datapoints, 
    data_size
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreateDatarangeUploadParams struct {
	DatarangeID         int64
	UploadID            string
	DataObjectKey       string
	IndexObjectKey      string
	FirstDatapointIndex int64
	NumberOfDatapoints  int64
	DataSize            int64
}

func (q *Queries) CreateDatarangeUpload(ctx context.Context, arg CreateDatarangeUploadParams) (int64, error) {
	row := q.db.QueryRow(ctx, createDatarangeUpload,
		arg.DatarangeID,
		arg.UploadID,
		arg.DataObjectKey,
		arg.IndexObjectKey,
		arg.FirstDatapointIndex,
		arg.NumberOfDatapoints,
		arg.DataSize,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const datasetExists = `-- name: DatasetExists :one
SELECT count(*) > 0
FROM datasets
`

func (q *Queries) DatasetExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, datasetExists)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteDatarange = `-- name: DeleteDatarange :exec
DELETE FROM dataranges WHERE id = $1
`

func (q *Queries) DeleteDatarange(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDatarange, id)
	return err
}

const deleteDatarangeUpload = `-- name: DeleteDatarangeUpload :exec
DELETE FROM datarange_uploads WHERE id = $1
`

func (q *Queries) DeleteDatarangeUpload(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDatarangeUpload, id)
	return err
}

const getAllDatarangeUploads = `-- name: GetAllDatarangeUploads :many
SELECT id, datarange_id, upload_id, first_datapoint_index, number_of_datapoints, data_size
FROM datarange_uploads
`

type GetAllDatarangeUploadsRow struct {
	ID                  int64
	DatarangeID         int64
	UploadID            string
	FirstDatapointIndex int64
	NumberOfDatapoints  int64
	DataSize            int64
}

func (q *Queries) GetAllDatarangeUploads(ctx context.Context) ([]GetAllDatarangeUploadsRow, error) {
	rows, err := q.db.Query(ctx, getAllDatarangeUploads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllDatarangeUploadsRow
	for rows.Next() {
		var i GetAllDatarangeUploadsRow
		if err := rows.Scan(
			&i.ID,
			&i.DatarangeID,
			&i.UploadID,
			&i.FirstDatapointIndex,
			&i.NumberOfDatapoints,
			&i.DataSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDataranges = `-- name: GetAllDataranges :many
SELECT id, dataset_id, min_datapoint_key, max_datapoint_key, size_bytes
FROM dataranges
`

type GetAllDatarangesRow struct {
	ID              int64
	DatasetID       int64
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
}

func (q *Queries) GetAllDataranges(ctx context.Context) ([]GetAllDatarangesRow, error) {
	rows, err := q.db.Query(ctx, getAllDataranges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllDatarangesRow
	for rows.Next() {
		var i GetAllDatarangesRow
		if err := rows.Scan(
			&i.ID,
			&i.DatasetID,
			&i.MinDatapointKey,
			&i.MaxDatapointKey,
			&i.SizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatarangeFields = `-- name: GetDatarangeFields :many
SELECT min_datapoint_key, max_datapoint_key, size_bytes
FROM dataranges
`

type GetDatarangeFieldsRow struct {
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
}

func (q *Queries) GetDatarangeFields(ctx context.Context) ([]GetDatarangeFieldsRow, error) {
	rows, err := q.db.Query(ctx, getDatarangeFields)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDatarangeFieldsRow
	for rows.Next() {
		var i GetDatarangeFieldsRow
		if err := rows.Scan(&i.MinDatapointKey, &i.MaxDatapointKey, &i.SizeBytes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatarangeUploadIDs = `-- name: GetDatarangeUploadIDs :many
SELECT upload_id
FROM datarange_uploads
`

func (q *Queries) GetDatarangeUploadIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getDatarangeUploadIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var upload_id string
		if err := rows.Scan(&upload_id); err != nil {
			return nil, err
		}
		items = append(items, upload_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatarangeUploadWithDetails = `-- name: GetDatarangeUploadWithDetails :one
SELECT 
    du.id, 
    du.datarange_id, 
    du.upload_id, 
    du.first_datapoint_index, 
    du.number_of_datapoints, 
    du.data_size,
    dr.data_object_key, 
    dr.index_object_key,
    dr.dataset_id,
    d.name as dataset_name, 
    d.s3_bucket_id,
    s.endpoint, 
    s.bucket, 
    s.access_key, 
    s.secret_key, 
    s.use_tls
FROM datarange_uploads du
JOIN dataranges dr ON du.datarange_id = dr.id  
JOIN datasets d ON dr.dataset_id = d.id
JOIN s3_buckets s ON d.s3_bucket_id = s.id
WHERE du.id = $1
`

type GetDatarangeUploadWithDetailsRow struct {
	ID                  int64
	DatarangeID         int64
	UploadID            string
	FirstDatapointIndex int64
	NumberOfDatapoints  int64
	DataSize            int64
	DataObjectKey       string
	IndexObjectKey      string
	DatasetID           int64
	DatasetName         string
	S3BucketID          int64
	Endpoint            string
	Bucket              string
	AccessKey           string
	SecretKey           string
	UseTls              bool
}

func (q *Queries) GetDatarangeUploadWithDetails(ctx context.Context, id int64) (GetDatarangeUploadWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getDatarangeUploadWithDetails, id)
	var i GetDatarangeUploadWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.DatarangeID,
		&i.UploadID,
		&i.FirstDatapointIndex,
		&i.NumberOfDatapoints,
		&i.DataSize,
		&i.DataObjectKey,
		&i.IndexObjectKey,
		&i.DatasetID,
		&i.DatasetName,
		&i.S3BucketID,
		&i.Endpoint,
		&i.Bucket,
		&i.AccessKey,
		&i.SecretKey,
		&i.UseTls,
	)
	return i, err
}

const getDatarangesForDatapoints = `-- name: GetDatarangesForDatapoints :many
SELECT 
    dr.id,
    dr.data_object_key,
    dr.index_object_key,
    dr.min_datapoint_key,
    dr.max_datapoint_key,
    dr.size_bytes,
    d.name as dataset_name,
    s.endpoint,
    s.bucket,
    s.access_key,
    s.secret_key,
    s.use_tls
FROM dataranges dr
JOIN datasets d ON dr.dataset_id = d.id
JOIN s3_buckets s ON d.s3_bucket_id = s.id
WHERE d.name = $1
  AND dr.min_datapoint_key <= $2  -- datarange starts before or at our last datapoint
  AND dr.max_datapoint_key >= $3  -- datarange ends after or at our first datapoint
ORDER BY dr.min_datapoint_key
`

type GetDatarangesForDatapointsParams struct {
	Name            string
	MinDatapointKey int64
	MaxDatapointKey int64
}

type GetDatarangesForDatapointsRow struct {
	ID              int64
	DataObjectKey   string
	IndexObjectKey  string
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
	DatasetName     string
	Endpoint        string
	Bucket          string
	AccessKey       string
	SecretKey       string
	UseTls          bool
}

func (q *Queries) GetDatarangesForDatapoints(ctx context.Context, arg GetDatarangesForDatapointsParams) ([]GetDatarangesForDatapointsRow, error) {
	rows, err := q.db.Query(ctx, getDatarangesForDatapoints, arg.Name, arg.MinDatapointKey, arg.MaxDatapointKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDatarangesForDatapointsRow
	for rows.Next() {
		var i GetDatarangesForDatapointsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataObjectKey,
			&i.IndexObjectKey,
			&i.MinDatapointKey,
			&i.MaxDatapointKey,
			&i.SizeBytes,
			&i.DatasetName,
			&i.Endpoint,
			&i.Bucket,
			&i.AccessKey,
			&i.SecretKey,
			&i.UseTls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatasetWithBucket = `-- name: GetDatasetWithBucket :one
SELECT d.id, d.name, d.s3_bucket_id, 
       s.endpoint, s.bucket, s.access_key, s.secret_key, s.use_tls
FROM datasets d
JOIN s3_buckets s ON d.s3_bucket_id = s.id
WHERE d.name = $1
`

type GetDatasetWithBucketRow struct {
	ID         int64
	Name       string
	S3BucketID int64
	Endpoint   string
	Bucket     string
	AccessKey  string
	SecretKey  string
	UseTls     bool
}

func (q *Queries) GetDatasetWithBucket(ctx context.Context, name string) (GetDatasetWithBucketRow, error) {
	row := q.db.QueryRow(ctx, getDatasetWithBucket, name)
	var i GetDatasetWithBucketRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.S3BucketID,
		&i.Endpoint,
		&i.Bucket,
		&i.AccessKey,
		&i.SecretKey,
		&i.UseTls,
	)
	return i, err
}

const listAllBuckets = `-- name: ListAllBuckets :many
SELECT name, endpoint, bucket, use_tls
FROM s3_buckets
ORDER BY name
`

type ListAllBucketsRow struct {
	Name     string
	Endpoint string
	Bucket   string
	UseTls   bool
}

func (q *Queries) ListAllBuckets(ctx context.Context) ([]ListAllBucketsRow, error) {
	rows, err := q.db.Query(ctx, listAllBuckets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllBucketsRow
	for rows.Next() {
		var i ListAllBucketsRow
		if err := rows.Scan(
			&i.Name,
			&i.Endpoint,
			&i.Bucket,
			&i.UseTls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatas3ts = `-- name: ListDatas3ts :many
SELECT 
    d.name as dataset_name,
    s.name as bucket_name,
    COALESCE(COUNT(dr.id), 0) as datarange_count,
    COALESCE(SUM(dr.max_datapoint_key - dr.min_datapoint_key + 1), 0) as total_datapoints,
    COALESCE(MIN(dr.min_datapoint_key), 0) as lowest_datapoint,
    COALESCE(MAX(dr.max_datapoint_key), 0) as highest_datapoint,
    COALESCE(SUM(dr.size_bytes), 0) as total_bytes
FROM datasets d
JOIN s3_buckets s ON d.s3_bucket_id = s.id
LEFT JOIN dataranges dr ON d.id = dr.dataset_id
GROUP BY d.id, d.name, s.name
ORDER BY d.name
`

type ListDatas3tsRow struct {
	DatasetName      string
	BucketName       string
	DatarangeCount   interface{}
	TotalDatapoints  interface{}
	LowestDatapoint  interface{}
	HighestDatapoint interface{}
	TotalBytes       interface{}
}

func (q *Queries) ListDatas3ts(ctx context.Context) ([]ListDatas3tsRow, error) {
	rows, err := q.db.Query(ctx, listDatas3ts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDatas3tsRow
	for rows.Next() {
		var i ListDatas3tsRow
		if err := rows.Scan(
			&i.DatasetName,
			&i.BucketName,
			&i.DatarangeCount,
			&i.TotalDatapoints,
			&i.LowestDatapoint,
			&i.HighestDatapoint,
			&i.TotalBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const scheduleKeyForDeletion = `-- name: ScheduleKeyForDeletion :exec
INSERT INTO keys_to_delete (presigned_delete_url, delete_after)
VALUES ($1, $2)
`

type ScheduleKeyForDeletionParams struct {
	PresignedDeleteUrl string
	DeleteAfter        pgtype.Timestamp
}

func (q *Queries) ScheduleKeyForDeletion(ctx context.Context, arg ScheduleKeyForDeletionParams) error {
	_, err := q.db.Exec(ctx, scheduleKeyForDeletion, arg.PresignedDeleteUrl, arg.DeleteAfter)
	return err
}
